// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'medical_records_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MedicalRecordsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() selectMedRec,
    required TResult Function(int index) removeAt,
    required TResult Function(bool needToSelect) uploadMedRec,
    required TResult Function() resetState,
    required TResult Function() getRecords,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? selectMedRec,
    TResult? Function(int index)? removeAt,
    TResult? Function(bool needToSelect)? uploadMedRec,
    TResult? Function()? resetState,
    TResult? Function()? getRecords,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? selectMedRec,
    TResult Function(int index)? removeAt,
    TResult Function(bool needToSelect)? uploadMedRec,
    TResult Function()? resetState,
    TResult Function()? getRecords,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SelectMedRec value) selectMedRec,
    required TResult Function(_RemoveAt value) removeAt,
    required TResult Function(_UploadMedRec value) uploadMedRec,
    required TResult Function(_ResetState value) resetState,
    required TResult Function(_GetRecords value) getRecords,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SelectMedRec value)? selectMedRec,
    TResult? Function(_RemoveAt value)? removeAt,
    TResult? Function(_UploadMedRec value)? uploadMedRec,
    TResult? Function(_ResetState value)? resetState,
    TResult? Function(_GetRecords value)? getRecords,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SelectMedRec value)? selectMedRec,
    TResult Function(_RemoveAt value)? removeAt,
    TResult Function(_UploadMedRec value)? uploadMedRec,
    TResult Function(_ResetState value)? resetState,
    TResult Function(_GetRecords value)? getRecords,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicalRecordsEventCopyWith<$Res> {
  factory $MedicalRecordsEventCopyWith(
          MedicalRecordsEvent value, $Res Function(MedicalRecordsEvent) then) =
      _$MedicalRecordsEventCopyWithImpl<$Res, MedicalRecordsEvent>;
}

/// @nodoc
class _$MedicalRecordsEventCopyWithImpl<$Res, $Val extends MedicalRecordsEvent>
    implements $MedicalRecordsEventCopyWith<$Res> {
  _$MedicalRecordsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SelectMedRecImplCopyWith<$Res> {
  factory _$$SelectMedRecImplCopyWith(
          _$SelectMedRecImpl value, $Res Function(_$SelectMedRecImpl) then) =
      __$$SelectMedRecImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectMedRecImplCopyWithImpl<$Res>
    extends _$MedicalRecordsEventCopyWithImpl<$Res, _$SelectMedRecImpl>
    implements _$$SelectMedRecImplCopyWith<$Res> {
  __$$SelectMedRecImplCopyWithImpl(
      _$SelectMedRecImpl _value, $Res Function(_$SelectMedRecImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SelectMedRecImpl implements _SelectMedRec {
  const _$SelectMedRecImpl();

  @override
  String toString() {
    return 'MedicalRecordsEvent.selectMedRec()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SelectMedRecImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() selectMedRec,
    required TResult Function(int index) removeAt,
    required TResult Function(bool needToSelect) uploadMedRec,
    required TResult Function() resetState,
    required TResult Function() getRecords,
  }) {
    return selectMedRec();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? selectMedRec,
    TResult? Function(int index)? removeAt,
    TResult? Function(bool needToSelect)? uploadMedRec,
    TResult? Function()? resetState,
    TResult? Function()? getRecords,
  }) {
    return selectMedRec?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? selectMedRec,
    TResult Function(int index)? removeAt,
    TResult Function(bool needToSelect)? uploadMedRec,
    TResult Function()? resetState,
    TResult Function()? getRecords,
    required TResult orElse(),
  }) {
    if (selectMedRec != null) {
      return selectMedRec();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SelectMedRec value) selectMedRec,
    required TResult Function(_RemoveAt value) removeAt,
    required TResult Function(_UploadMedRec value) uploadMedRec,
    required TResult Function(_ResetState value) resetState,
    required TResult Function(_GetRecords value) getRecords,
  }) {
    return selectMedRec(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SelectMedRec value)? selectMedRec,
    TResult? Function(_RemoveAt value)? removeAt,
    TResult? Function(_UploadMedRec value)? uploadMedRec,
    TResult? Function(_ResetState value)? resetState,
    TResult? Function(_GetRecords value)? getRecords,
  }) {
    return selectMedRec?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SelectMedRec value)? selectMedRec,
    TResult Function(_RemoveAt value)? removeAt,
    TResult Function(_UploadMedRec value)? uploadMedRec,
    TResult Function(_ResetState value)? resetState,
    TResult Function(_GetRecords value)? getRecords,
    required TResult orElse(),
  }) {
    if (selectMedRec != null) {
      return selectMedRec(this);
    }
    return orElse();
  }
}

abstract class _SelectMedRec implements MedicalRecordsEvent {
  const factory _SelectMedRec() = _$SelectMedRecImpl;
}

/// @nodoc
abstract class _$$RemoveAtImplCopyWith<$Res> {
  factory _$$RemoveAtImplCopyWith(
          _$RemoveAtImpl value, $Res Function(_$RemoveAtImpl) then) =
      __$$RemoveAtImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$RemoveAtImplCopyWithImpl<$Res>
    extends _$MedicalRecordsEventCopyWithImpl<$Res, _$RemoveAtImpl>
    implements _$$RemoveAtImplCopyWith<$Res> {
  __$$RemoveAtImplCopyWithImpl(
      _$RemoveAtImpl _value, $Res Function(_$RemoveAtImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$RemoveAtImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$RemoveAtImpl implements _RemoveAt {
  const _$RemoveAtImpl(this.index);

  @override
  final int index;

  @override
  String toString() {
    return 'MedicalRecordsEvent.removeAt(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RemoveAtImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RemoveAtImplCopyWith<_$RemoveAtImpl> get copyWith =>
      __$$RemoveAtImplCopyWithImpl<_$RemoveAtImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() selectMedRec,
    required TResult Function(int index) removeAt,
    required TResult Function(bool needToSelect) uploadMedRec,
    required TResult Function() resetState,
    required TResult Function() getRecords,
  }) {
    return removeAt(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? selectMedRec,
    TResult? Function(int index)? removeAt,
    TResult? Function(bool needToSelect)? uploadMedRec,
    TResult? Function()? resetState,
    TResult? Function()? getRecords,
  }) {
    return removeAt?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? selectMedRec,
    TResult Function(int index)? removeAt,
    TResult Function(bool needToSelect)? uploadMedRec,
    TResult Function()? resetState,
    TResult Function()? getRecords,
    required TResult orElse(),
  }) {
    if (removeAt != null) {
      return removeAt(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SelectMedRec value) selectMedRec,
    required TResult Function(_RemoveAt value) removeAt,
    required TResult Function(_UploadMedRec value) uploadMedRec,
    required TResult Function(_ResetState value) resetState,
    required TResult Function(_GetRecords value) getRecords,
  }) {
    return removeAt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SelectMedRec value)? selectMedRec,
    TResult? Function(_RemoveAt value)? removeAt,
    TResult? Function(_UploadMedRec value)? uploadMedRec,
    TResult? Function(_ResetState value)? resetState,
    TResult? Function(_GetRecords value)? getRecords,
  }) {
    return removeAt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SelectMedRec value)? selectMedRec,
    TResult Function(_RemoveAt value)? removeAt,
    TResult Function(_UploadMedRec value)? uploadMedRec,
    TResult Function(_ResetState value)? resetState,
    TResult Function(_GetRecords value)? getRecords,
    required TResult orElse(),
  }) {
    if (removeAt != null) {
      return removeAt(this);
    }
    return orElse();
  }
}

abstract class _RemoveAt implements MedicalRecordsEvent {
  const factory _RemoveAt(final int index) = _$RemoveAtImpl;

  int get index;
  @JsonKey(ignore: true)
  _$$RemoveAtImplCopyWith<_$RemoveAtImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UploadMedRecImplCopyWith<$Res> {
  factory _$$UploadMedRecImplCopyWith(
          _$UploadMedRecImpl value, $Res Function(_$UploadMedRecImpl) then) =
      __$$UploadMedRecImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool needToSelect});
}

/// @nodoc
class __$$UploadMedRecImplCopyWithImpl<$Res>
    extends _$MedicalRecordsEventCopyWithImpl<$Res, _$UploadMedRecImpl>
    implements _$$UploadMedRecImplCopyWith<$Res> {
  __$$UploadMedRecImplCopyWithImpl(
      _$UploadMedRecImpl _value, $Res Function(_$UploadMedRecImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? needToSelect = null,
  }) {
    return _then(_$UploadMedRecImpl(
      null == needToSelect
          ? _value.needToSelect
          : needToSelect // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$UploadMedRecImpl implements _UploadMedRec {
  const _$UploadMedRecImpl(this.needToSelect);

  @override
  final bool needToSelect;

  @override
  String toString() {
    return 'MedicalRecordsEvent.uploadMedRec(needToSelect: $needToSelect)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UploadMedRecImpl &&
            (identical(other.needToSelect, needToSelect) ||
                other.needToSelect == needToSelect));
  }

  @override
  int get hashCode => Object.hash(runtimeType, needToSelect);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UploadMedRecImplCopyWith<_$UploadMedRecImpl> get copyWith =>
      __$$UploadMedRecImplCopyWithImpl<_$UploadMedRecImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() selectMedRec,
    required TResult Function(int index) removeAt,
    required TResult Function(bool needToSelect) uploadMedRec,
    required TResult Function() resetState,
    required TResult Function() getRecords,
  }) {
    return uploadMedRec(needToSelect);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? selectMedRec,
    TResult? Function(int index)? removeAt,
    TResult? Function(bool needToSelect)? uploadMedRec,
    TResult? Function()? resetState,
    TResult? Function()? getRecords,
  }) {
    return uploadMedRec?.call(needToSelect);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? selectMedRec,
    TResult Function(int index)? removeAt,
    TResult Function(bool needToSelect)? uploadMedRec,
    TResult Function()? resetState,
    TResult Function()? getRecords,
    required TResult orElse(),
  }) {
    if (uploadMedRec != null) {
      return uploadMedRec(needToSelect);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SelectMedRec value) selectMedRec,
    required TResult Function(_RemoveAt value) removeAt,
    required TResult Function(_UploadMedRec value) uploadMedRec,
    required TResult Function(_ResetState value) resetState,
    required TResult Function(_GetRecords value) getRecords,
  }) {
    return uploadMedRec(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SelectMedRec value)? selectMedRec,
    TResult? Function(_RemoveAt value)? removeAt,
    TResult? Function(_UploadMedRec value)? uploadMedRec,
    TResult? Function(_ResetState value)? resetState,
    TResult? Function(_GetRecords value)? getRecords,
  }) {
    return uploadMedRec?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SelectMedRec value)? selectMedRec,
    TResult Function(_RemoveAt value)? removeAt,
    TResult Function(_UploadMedRec value)? uploadMedRec,
    TResult Function(_ResetState value)? resetState,
    TResult Function(_GetRecords value)? getRecords,
    required TResult orElse(),
  }) {
    if (uploadMedRec != null) {
      return uploadMedRec(this);
    }
    return orElse();
  }
}

abstract class _UploadMedRec implements MedicalRecordsEvent {
  const factory _UploadMedRec(final bool needToSelect) = _$UploadMedRecImpl;

  bool get needToSelect;
  @JsonKey(ignore: true)
  _$$UploadMedRecImplCopyWith<_$UploadMedRecImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ResetStateImplCopyWith<$Res> {
  factory _$$ResetStateImplCopyWith(
          _$ResetStateImpl value, $Res Function(_$ResetStateImpl) then) =
      __$$ResetStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ResetStateImplCopyWithImpl<$Res>
    extends _$MedicalRecordsEventCopyWithImpl<$Res, _$ResetStateImpl>
    implements _$$ResetStateImplCopyWith<$Res> {
  __$$ResetStateImplCopyWithImpl(
      _$ResetStateImpl _value, $Res Function(_$ResetStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ResetStateImpl implements _ResetState {
  const _$ResetStateImpl();

  @override
  String toString() {
    return 'MedicalRecordsEvent.resetState()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ResetStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() selectMedRec,
    required TResult Function(int index) removeAt,
    required TResult Function(bool needToSelect) uploadMedRec,
    required TResult Function() resetState,
    required TResult Function() getRecords,
  }) {
    return resetState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? selectMedRec,
    TResult? Function(int index)? removeAt,
    TResult? Function(bool needToSelect)? uploadMedRec,
    TResult? Function()? resetState,
    TResult? Function()? getRecords,
  }) {
    return resetState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? selectMedRec,
    TResult Function(int index)? removeAt,
    TResult Function(bool needToSelect)? uploadMedRec,
    TResult Function()? resetState,
    TResult Function()? getRecords,
    required TResult orElse(),
  }) {
    if (resetState != null) {
      return resetState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SelectMedRec value) selectMedRec,
    required TResult Function(_RemoveAt value) removeAt,
    required TResult Function(_UploadMedRec value) uploadMedRec,
    required TResult Function(_ResetState value) resetState,
    required TResult Function(_GetRecords value) getRecords,
  }) {
    return resetState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SelectMedRec value)? selectMedRec,
    TResult? Function(_RemoveAt value)? removeAt,
    TResult? Function(_UploadMedRec value)? uploadMedRec,
    TResult? Function(_ResetState value)? resetState,
    TResult? Function(_GetRecords value)? getRecords,
  }) {
    return resetState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SelectMedRec value)? selectMedRec,
    TResult Function(_RemoveAt value)? removeAt,
    TResult Function(_UploadMedRec value)? uploadMedRec,
    TResult Function(_ResetState value)? resetState,
    TResult Function(_GetRecords value)? getRecords,
    required TResult orElse(),
  }) {
    if (resetState != null) {
      return resetState(this);
    }
    return orElse();
  }
}

abstract class _ResetState implements MedicalRecordsEvent {
  const factory _ResetState() = _$ResetStateImpl;
}

/// @nodoc
abstract class _$$GetRecordsImplCopyWith<$Res> {
  factory _$$GetRecordsImplCopyWith(
          _$GetRecordsImpl value, $Res Function(_$GetRecordsImpl) then) =
      __$$GetRecordsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetRecordsImplCopyWithImpl<$Res>
    extends _$MedicalRecordsEventCopyWithImpl<$Res, _$GetRecordsImpl>
    implements _$$GetRecordsImplCopyWith<$Res> {
  __$$GetRecordsImplCopyWithImpl(
      _$GetRecordsImpl _value, $Res Function(_$GetRecordsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetRecordsImpl implements _GetRecords {
  const _$GetRecordsImpl();

  @override
  String toString() {
    return 'MedicalRecordsEvent.getRecords()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetRecordsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() selectMedRec,
    required TResult Function(int index) removeAt,
    required TResult Function(bool needToSelect) uploadMedRec,
    required TResult Function() resetState,
    required TResult Function() getRecords,
  }) {
    return getRecords();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? selectMedRec,
    TResult? Function(int index)? removeAt,
    TResult? Function(bool needToSelect)? uploadMedRec,
    TResult? Function()? resetState,
    TResult? Function()? getRecords,
  }) {
    return getRecords?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? selectMedRec,
    TResult Function(int index)? removeAt,
    TResult Function(bool needToSelect)? uploadMedRec,
    TResult Function()? resetState,
    TResult Function()? getRecords,
    required TResult orElse(),
  }) {
    if (getRecords != null) {
      return getRecords();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SelectMedRec value) selectMedRec,
    required TResult Function(_RemoveAt value) removeAt,
    required TResult Function(_UploadMedRec value) uploadMedRec,
    required TResult Function(_ResetState value) resetState,
    required TResult Function(_GetRecords value) getRecords,
  }) {
    return getRecords(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SelectMedRec value)? selectMedRec,
    TResult? Function(_RemoveAt value)? removeAt,
    TResult? Function(_UploadMedRec value)? uploadMedRec,
    TResult? Function(_ResetState value)? resetState,
    TResult? Function(_GetRecords value)? getRecords,
  }) {
    return getRecords?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SelectMedRec value)? selectMedRec,
    TResult Function(_RemoveAt value)? removeAt,
    TResult Function(_UploadMedRec value)? uploadMedRec,
    TResult Function(_ResetState value)? resetState,
    TResult Function(_GetRecords value)? getRecords,
    required TResult orElse(),
  }) {
    if (getRecords != null) {
      return getRecords(this);
    }
    return orElse();
  }
}

abstract class _GetRecords implements MedicalRecordsEvent {
  const factory _GetRecords() = _$GetRecordsImpl;
}

/// @nodoc
mixin _$MedicalRecordsState {
  List<XFile> get selectedMedicalRecords => throw _privateConstructorUsedError;
  bool get isUploading => throw _privateConstructorUsedError;
  bool get isGettingRecords => throw _privateConstructorUsedError;
  Option<Either<MainFailure, void>> get getfailureOrMedicalRecords =>
      throw _privateConstructorUsedError;
  MedicalRecordModel? get medicalRecordModel =>
      throw _privateConstructorUsedError;
  Option<Either<MainFailure, void>> get failureOrMedicalRecords =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MedicalRecordsStateCopyWith<MedicalRecordsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicalRecordsStateCopyWith<$Res> {
  factory $MedicalRecordsStateCopyWith(
          MedicalRecordsState value, $Res Function(MedicalRecordsState) then) =
      _$MedicalRecordsStateCopyWithImpl<$Res, MedicalRecordsState>;
  @useResult
  $Res call(
      {List<XFile> selectedMedicalRecords,
      bool isUploading,
      bool isGettingRecords,
      Option<Either<MainFailure, void>> getfailureOrMedicalRecords,
      MedicalRecordModel? medicalRecordModel,
      Option<Either<MainFailure, void>> failureOrMedicalRecords});
}

/// @nodoc
class _$MedicalRecordsStateCopyWithImpl<$Res, $Val extends MedicalRecordsState>
    implements $MedicalRecordsStateCopyWith<$Res> {
  _$MedicalRecordsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectedMedicalRecords = null,
    Object? isUploading = null,
    Object? isGettingRecords = null,
    Object? getfailureOrMedicalRecords = null,
    Object? medicalRecordModel = freezed,
    Object? failureOrMedicalRecords = null,
  }) {
    return _then(_value.copyWith(
      selectedMedicalRecords: null == selectedMedicalRecords
          ? _value.selectedMedicalRecords
          : selectedMedicalRecords // ignore: cast_nullable_to_non_nullable
              as List<XFile>,
      isUploading: null == isUploading
          ? _value.isUploading
          : isUploading // ignore: cast_nullable_to_non_nullable
              as bool,
      isGettingRecords: null == isGettingRecords
          ? _value.isGettingRecords
          : isGettingRecords // ignore: cast_nullable_to_non_nullable
              as bool,
      getfailureOrMedicalRecords: null == getfailureOrMedicalRecords
          ? _value.getfailureOrMedicalRecords
          : getfailureOrMedicalRecords // ignore: cast_nullable_to_non_nullable
              as Option<Either<MainFailure, void>>,
      medicalRecordModel: freezed == medicalRecordModel
          ? _value.medicalRecordModel
          : medicalRecordModel // ignore: cast_nullable_to_non_nullable
              as MedicalRecordModel?,
      failureOrMedicalRecords: null == failureOrMedicalRecords
          ? _value.failureOrMedicalRecords
          : failureOrMedicalRecords // ignore: cast_nullable_to_non_nullable
              as Option<Either<MainFailure, void>>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MedicalRecordsStateImplCopyWith<$Res>
    implements $MedicalRecordsStateCopyWith<$Res> {
  factory _$$MedicalRecordsStateImplCopyWith(_$MedicalRecordsStateImpl value,
          $Res Function(_$MedicalRecordsStateImpl) then) =
      __$$MedicalRecordsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<XFile> selectedMedicalRecords,
      bool isUploading,
      bool isGettingRecords,
      Option<Either<MainFailure, void>> getfailureOrMedicalRecords,
      MedicalRecordModel? medicalRecordModel,
      Option<Either<MainFailure, void>> failureOrMedicalRecords});
}

/// @nodoc
class __$$MedicalRecordsStateImplCopyWithImpl<$Res>
    extends _$MedicalRecordsStateCopyWithImpl<$Res, _$MedicalRecordsStateImpl>
    implements _$$MedicalRecordsStateImplCopyWith<$Res> {
  __$$MedicalRecordsStateImplCopyWithImpl(_$MedicalRecordsStateImpl _value,
      $Res Function(_$MedicalRecordsStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectedMedicalRecords = null,
    Object? isUploading = null,
    Object? isGettingRecords = null,
    Object? getfailureOrMedicalRecords = null,
    Object? medicalRecordModel = freezed,
    Object? failureOrMedicalRecords = null,
  }) {
    return _then(_$MedicalRecordsStateImpl(
      selectedMedicalRecords: null == selectedMedicalRecords
          ? _value._selectedMedicalRecords
          : selectedMedicalRecords // ignore: cast_nullable_to_non_nullable
              as List<XFile>,
      isUploading: null == isUploading
          ? _value.isUploading
          : isUploading // ignore: cast_nullable_to_non_nullable
              as bool,
      isGettingRecords: null == isGettingRecords
          ? _value.isGettingRecords
          : isGettingRecords // ignore: cast_nullable_to_non_nullable
              as bool,
      getfailureOrMedicalRecords: null == getfailureOrMedicalRecords
          ? _value.getfailureOrMedicalRecords
          : getfailureOrMedicalRecords // ignore: cast_nullable_to_non_nullable
              as Option<Either<MainFailure, void>>,
      medicalRecordModel: freezed == medicalRecordModel
          ? _value.medicalRecordModel
          : medicalRecordModel // ignore: cast_nullable_to_non_nullable
              as MedicalRecordModel?,
      failureOrMedicalRecords: null == failureOrMedicalRecords
          ? _value.failureOrMedicalRecords
          : failureOrMedicalRecords // ignore: cast_nullable_to_non_nullable
              as Option<Either<MainFailure, void>>,
    ));
  }
}

/// @nodoc

class _$MedicalRecordsStateImpl implements _MedicalRecordsState {
  const _$MedicalRecordsStateImpl(
      {required final List<XFile> selectedMedicalRecords,
      required this.isUploading,
      required this.isGettingRecords,
      required this.getfailureOrMedicalRecords,
      required this.medicalRecordModel,
      required this.failureOrMedicalRecords})
      : _selectedMedicalRecords = selectedMedicalRecords;

  final List<XFile> _selectedMedicalRecords;
  @override
  List<XFile> get selectedMedicalRecords {
    if (_selectedMedicalRecords is EqualUnmodifiableListView)
      return _selectedMedicalRecords;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_selectedMedicalRecords);
  }

  @override
  final bool isUploading;
  @override
  final bool isGettingRecords;
  @override
  final Option<Either<MainFailure, void>> getfailureOrMedicalRecords;
  @override
  final MedicalRecordModel? medicalRecordModel;
  @override
  final Option<Either<MainFailure, void>> failureOrMedicalRecords;

  @override
  String toString() {
    return 'MedicalRecordsState(selectedMedicalRecords: $selectedMedicalRecords, isUploading: $isUploading, isGettingRecords: $isGettingRecords, getfailureOrMedicalRecords: $getfailureOrMedicalRecords, medicalRecordModel: $medicalRecordModel, failureOrMedicalRecords: $failureOrMedicalRecords)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MedicalRecordsStateImpl &&
            const DeepCollectionEquality().equals(
                other._selectedMedicalRecords, _selectedMedicalRecords) &&
            (identical(other.isUploading, isUploading) ||
                other.isUploading == isUploading) &&
            (identical(other.isGettingRecords, isGettingRecords) ||
                other.isGettingRecords == isGettingRecords) &&
            (identical(other.getfailureOrMedicalRecords,
                    getfailureOrMedicalRecords) ||
                other.getfailureOrMedicalRecords ==
                    getfailureOrMedicalRecords) &&
            (identical(other.medicalRecordModel, medicalRecordModel) ||
                other.medicalRecordModel == medicalRecordModel) &&
            (identical(
                    other.failureOrMedicalRecords, failureOrMedicalRecords) ||
                other.failureOrMedicalRecords == failureOrMedicalRecords));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_selectedMedicalRecords),
      isUploading,
      isGettingRecords,
      getfailureOrMedicalRecords,
      medicalRecordModel,
      failureOrMedicalRecords);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MedicalRecordsStateImplCopyWith<_$MedicalRecordsStateImpl> get copyWith =>
      __$$MedicalRecordsStateImplCopyWithImpl<_$MedicalRecordsStateImpl>(
          this, _$identity);
}

abstract class _MedicalRecordsState implements MedicalRecordsState {
  const factory _MedicalRecordsState(
      {required final List<XFile> selectedMedicalRecords,
      required final bool isUploading,
      required final bool isGettingRecords,
      required final Option<Either<MainFailure, void>>
          getfailureOrMedicalRecords,
      required final MedicalRecordModel? medicalRecordModel,
      required final Option<Either<MainFailure, void>>
          failureOrMedicalRecords}) = _$MedicalRecordsStateImpl;

  @override
  List<XFile> get selectedMedicalRecords;
  @override
  bool get isUploading;
  @override
  bool get isGettingRecords;
  @override
  Option<Either<MainFailure, void>> get getfailureOrMedicalRecords;
  @override
  MedicalRecordModel? get medicalRecordModel;
  @override
  Option<Either<MainFailure, void>> get failureOrMedicalRecords;
  @override
  @JsonKey(ignore: true)
  _$$MedicalRecordsStateImplCopyWith<_$MedicalRecordsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
